package mapping;import geometry.*;/** The pylon mapping CarDriver controls the car with the goal of mapping out an area with minimal error.  It drives slowly, carefully, and slows down even more if obstacle   detection lowers its confidence levels.      PylonMappingCarDriver is a poor driver if the map includes ramps.*/public class PylonMappingCarDriver extends CarDriver{ private static final int DEFAULT=0; private static final int STOPPING_FOR_STABILITY_OF_SYSTEM=1; private static final int MILLISECONDS_TO_STOP_FOR_STABILITY_OF_SYSTEM=3000; /** Don't steer into any point closer than this distance to an obstacle.*/ private static final double DISTANCE_CUT_OFF = 120; private long timer=0; private long lastTime=0; private int state=DEFAULT;   public Vector2D getTargetPoint(double [][] distances,int size,int miny)  {    int x,y;  	 x=size/2;	 y=size*3/10;	 double cutoffdistance=Math.min(DISTANCE_CUT_OFF,distances[x][y]*0.9);	 boolean done=false;	 boolean visited[][]=new boolean[size][size];	 	 	 for (int x2=0;x2<visited.length;x2++)	     for (int y2=0;y2<visited[x2].length;y2++)		    visited[x2][y2]=false;	 	// System.out.println("getNewDriveSettingsFrom called.");	 /**	 Follow the maximum distance cells along a path from 	 lidar out infront of the sensor.	 */	 for (y=0;y<size-1 && y>=0 && !done;y++)	 {	   double maxDistance=Double.MIN_VALUE;	   int bestDX=0;	   int bestDY=0;	   	   for (int dy=miny;dy<2;dy++)	   for (int dx=-1;dx<2;dx++)	   {	     if (dy+y<0 || dy+y>=size)		    continue;				     if (dx==0 && (dy==-1 || dy==0)) // we have to move so skip this case.		    continue;				     if (x+dx<0 || x+dx>=distances.length)		 {		    done=true;	        break;		 }		 		 if (visited[x+dx][y+dy])		    continue;		     double distance = distances[x+dx][y+dy];	   	      if (maxDistance<distance)	  	  {		     bestDX=dx;			 bestDY=dy;		     maxDistance=distance;			 visited[x+dx][y+dy]=true;			  // mark it to not return here.		  }	    }		if (!done)		{		   if (maxDistance<cutoffdistance)		   {		      done=true;		      break;		   }  		   x+=bestDX;		   y+=bestDY;		}	 }	 	 return new Vector2D(x+0.1-size/2,y-size*3/10+0.1);  }  public DriveSettings getNewDriveSettingsFrom(ObstacleMap map)  {    if (state==STOPPING_FOR_STABILITY_OF_SYSTEM)	{	    timer+=map.getLastMergeTime()-lastTime;		if (timer>MILLISECONDS_TO_STOP_FOR_STABILITY_OF_SYSTEM)		{		   state=DEFAULT; // stopped for a while but now it is time to move again.		   timer=0;		}		else		{		   lastTime=map.getLastMergeTime();	       return new DriveSettings(0,0);		}	}    if (map.isUnstable())	{	   state=STOPPING_FOR_STABILITY_OF_SYSTEM;	   timer=0;	   lastTime=map.getLastMergeTime();	   map.clear();	   return new DriveSettings(0,0);	}    double gsize=15;	int size = 15;	double[][]distances = map.createObstacleDistanceGrid(size,gsize);	  	 // find a good path through the grid with maximum distance each time.	 // start at the point just infront of the lidar.	 int x,y;	 double maxM = Double.MIN_VALUE;	 Vector2D maxMagnitudeV=null;	 	 for (int ymin=-1;ymin<2;ymin++)	 {	    Vector2D p = getTargetPoint(distances,size,ymin);		double mag = p.getMagnitude();		if (mag>maxM)		{		   maxM=mag;		   maxMagnitudeV=p;		}	 }	 x=(int)maxMagnitudeV.getX();	 y=(int)maxMagnitudeV.getY();		 	 // calculate the resulting desired angle.	 double angle = Math.atan2(y,x)-Math.PI/2;	// System.out.println("angle="+angle*180/Math.PI+" degrees, x="+x+", y="+y);	 	 double speed = 4;	 	   if (Math.abs(angle*180/Math.PI)<7)	      speed=10;	   else if (Math.abs(angle*180/Math.PI)<10)	      speed = 6;	 	 lastTime=map.getLastMergeTime();     return new DriveSettings(speed,angle*65);  }}