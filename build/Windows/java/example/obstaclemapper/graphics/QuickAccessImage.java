package graphics;import java.awt.image.*; // BufferedImageimport java.awt.Graphics;import java.awt.Image;/***/public class QuickAccessImage{ private BufferedImage img; private int[] pixelData; private int width,height;  public QuickAccessImage(int width,int height) {    assert width>=1;	assert height>=1;	    img = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);	pixelData = (int[])((DataBufferInt)img.getRaster().getDataBuffer()).getData();	this.width=width;	this.height=height; }  public QuickAccessImage(BufferedImage img) {    this(img.getWidth(),img.getHeight());	Graphics g = this.img.getGraphics();	g.drawImage(img,0,0,null); // copy the parameter image to the internal one. }  /** Assumes that the width and height of the specified image can be found immediately. */ public QuickAccessImage(Image img) {    this(img.getWidth(null),img.getHeight(null));	Graphics g = this.img.getGraphics();	g.drawImage(img,0,0,null); // copy the parameter image to the internal one. }  public QuickAccessImage(QuickAccessImage img) {   this(img.getInternalImage()); }  /**  width and height are assumed to be smaller than those attributes of the img. */ public static QuickAccessImage shrink(QuickAccessImage img,int width,int height) {   QuickAccessImage result = new QuickAccessImage(width,height);	 	 Graphics g = result.img.getGraphics();	 g.drawImage(img.img,0,0,null);	 return result; }   public int[] getPixelData() {    return pixelData; }  public int getPixelUnchecked(int x,int y) {    return pixelData[x+y*width]; }  /** Gets the red value of from the specified pixel value. The range is from 0 to 255. */ public static int getRed(int pixelValue) {    return (pixelValue>>16)&0xff; }   /** Gets the green value of from the specified pixel value. The range is from 0 to 255. */ public static int getGreen(int pixelValue) {    return (pixelValue>>8)&0xff; }   /** Gets the blue value of from the specified pixel value. The range is from 0 to 255. */ public static int getBlue(int pixelValue) {    return (pixelValue) &0xff; }   /** Gets the integer value of from the specified pixel. The pixel value is packed with its red, green, and blue values in separate bytes. The order can be understood by this hexidecimal format: 0x??RRGGBB where the question marks are ignored. For example, the blue value is in the lowest order byte and can be filtered out using a pixel value x&0xff. */ public static int getPixelValue(int red,int green,int blue) {    return (red<<16) | (green<<8) | (blue); }  /** If x or y are out of boundaries of this image, 0 is returned.  The pixel value is packed with its red, green, and blue values in separate bytes. The order can be understood by this hexidecimal format: 0x??RRGGBB where the question marks are ignored. */ public int getPixel(int x,int y) {    if (x<0||x>=width || y<0 || y>=height)       return 0;	   	return getPixelUnchecked(x,y); }  public static int getIntensity(int r,int g,int b) {   return (r+g+b)/3; }  public static int getValue(int r,int g,int b) {   return Math.max(Math.max(r,g),b); }  public static int getMin(int r,int g,int b) {    return Math.min(Math.min(r,g),b); }  public static int getLuminosity(int r,int g,int b) {   return (getMin(r,g,b)+getValue(r,g,b))/2; }  /** Sets the specified pixel to the specified value.  If x or y are out of boundaries of this image, nothing happens.  @param colour is assumed to contain red, green, blue values in the same format returned by getPixel.  The pixel value is packed with its red, green, and blue values in separate bytes. The order can be understood by this hexidecimal format: 0x??RRGGBB where the question marks are ignored. */ public void setPixel(int colour,int x,int y) {    if (x<0||x>=width || y<0 || y>=height)       return;	   	setPixelUnchecked(colour,x,y); }  private void setPixelUnchecked(int colour,int x,int y) {    pixelData[x+y*width]=colour; }  /**  Splits this image into grayscaled red, green, and blue channels.  Returns an array containing 3 new QuickAccessImage elements.  index 0 for red, 1 for green, and 2 for blue. */ public QuickAccessImage[] getRGBSplit() {    QuickAccessImage[] result = new QuickAccessImage[3];		for (int i=0;i<3;i++)	{	   result[i] = new QuickAccessImage(width,height);	}		for (int i=0;i<pixelData.length;i++)	{	   int v=pixelData[i];	   int r=(v>>16)&0xff,g=(v>>8)&0xff,b=v&0xff;        result[0].pixelData[i]=r | (r<<8)|(r<<16);		result[1].pixelData[i]=g | (g<<8)|(g<<16);		result[2].pixelData[i]=b | (b<<8)|(b<<16);	}	return result; }  public int getWidth() {    return width; }  public int getHeight() {    return height; }  public BufferedImage getInternalImage() {    return img; }}